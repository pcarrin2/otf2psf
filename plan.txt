[font writing part]

fairly simple. the font format is simple. should be self-contained.

[ttf bitmap extracting part] -- mostly implemented in ttf_parser.rs, but no support for BitmapMonoPacked bmps yet

- pull font data out as Glyphs
- for GlyphImages, assume format is BitmapMono or BitmapMonoPacked, reject otherwise
- yoink data and convert to the right format -- BitmapMono
- save metadata about each glyph (in a crate-specific struct probably)
	- what grapheme it represents
	- dimensions

- for each reference grapheme, get glyph (by combining multiple if necessary)
- sort by dimensions into set of sets
- debug-print all this data
- if glyph sizes differ:
	- either issue an unrecoverable error or pad everything to greatest dims
- ok we're good on sizes. now follow unicode table and pack everything up.


[font glyph handling part] -- covered in glyph.rs

- operations on glyphs:
	- append character and overlay glyphs (to make multi-codepoint graphemes)
	- pad to given dimensions
	- create from ab_glyph::GlyphImage

- glyph structs should only support mono-color, data should always be in psf2 format

struct Glyph {
	height: u8,
	width: u8,
	data: Vec<u8>,
	grapheme: String,
}

* layering characters of different dimensions should probably fail
* with that in mind, the layering/appending operation can be REALLY simple, just bitwise OR the data
* padding to dimensions is only a tiny bit annoying

[unicode table part] -- covered in unicode_table.rs and unicode_table_grammar.pest

maybe the worst part?
finite state machine?

example good input:
u+0123
u+abcd u+def0, u+1234, u+5678
u+0022, u+5098
u+0011 u+2233

example bad-ish input that shouldn't kill anything:
U+0011,
U+5566,		U+7890,,

U+4433	U+5987	U+6789,	U+890a

anyway. parsing machine?
nope, sounds like a PEG is a better option
i'll do this later <3
